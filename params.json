{"name":"Exbuffer","body":"ExBuffer，NodeJs的TCP中的粘包、分包问题的解决方案！\r\n\r\n推荐结合ByteBuffer来做通信协议！https://github.com/play175/ByteBuffer\r\n\r\n```javascript\r\nvar ExBuffer = require('./ExBuffer');\r\n\r\n/*************************基本操作****************************/\r\n\r\n//构造一个ExBuffer，采用4个字节（uint32无符号整型）表示包长，而且是little endian 字节序\r\nvar exBuffer = new ExBuffer().uint32Head().littleEndian();\r\n//或者构造一个ExBuffer，采用2个字节（ushort型）表示包长，而且是big endian 字节序 (默认)\r\nvar exBuffer = new ExBuffer().ushortHead().bigEndian();\r\n\r\n//只要收到满足的包就会触发事件\r\nexBuffer.on('data',function(buffer){\r\n    console.log('>> receive data,length:'+buffer.length);\r\n    //console.log(buffer);\r\n});\r\n\r\n\r\n//传入一个9字节长的数据，分多次put （对应于TCP中的分包的情况）\r\nexBuffer.put(new Buffer([0,9]));\r\nexBuffer.put(new Buffer([1,2,3,4,5,6,7]));\r\nexBuffer.put(new Buffer([8,9]));\r\n\r\n//传入一个3个字节的数据和一个6个字节的数据，一次put（对应于TCP中的粘包的情况）\r\nexBuffer.put(new Buffer([0,3,1,2,3,0,6,1,2,3,4,5,6]));\r\n\r\n\r\n//大数据处理测试 (20MB)\r\nvar exBuffer = new ExBuffer().uint32Head().bigEndian();\r\nexBuffer.on('data',function(buffer){\r\n    console.log('>> receive data,length:'+buffer.length);\r\n    console.log(buffer);\r\n});\r\nvar sbuf = new Buffer(4);\r\nsbuf.writeUInt32BE(1024*1024*20,0);//写入包长\r\nexBuffer.put(sbuf);\r\nexBuffer.put(new Buffer(1024*1024*20));\r\n\r\n\r\n/*************************在socket中的应用****************************/\r\n\r\nconsole.log('-----------------------use in socket------------------------');\r\n\r\nvar net = require('net');\r\n\r\n//测试服务端\r\nvar server = net.createServer(function(socket) {\r\n  console.log('client connected');\r\n  new Connection(socket);//有客户端连入时\r\n});\r\nserver.listen(8124);\r\n\r\n//服务端中映射客户端的类\r\nfunction Connection(socket) {\r\n    var exBuffer = new ExBuffer();\r\n    exBuffer.on('data',onReceivePackData);\r\n\r\n    socket.on('data', function(data) {\r\n        exBuffer.put(data);//只要收到数据就往ExBuffer里面put\r\n    });\r\n\r\n    //当服务端收到完整的包时\r\n    function onReceivePackData(buffer){\r\n        console.log('>> server receive data,length:'+buffer.length);\r\n        console.log(buffer.toString());\r\n\r\n        var data = 'wellcom, I am server';\r\n        var len = Buffer.byteLength(data);\r\n\r\n        //写入2个字节表示本次包长\r\n        var headBuf = new Buffer(2);\r\n        headBuf.writeUInt16BE(len, 0)\r\n        socket.write(headBuf);\r\n\r\n        var bodyBuf = new Buffer(len);\r\n        bodyBuf.write(data);\r\n        socket.write(bodyBuf);\r\n    }\r\n}\r\n\r\n//测试客户端\r\nvar exBuffer = new ExBuffer();\r\nvar client = net.connect(8124, function() {\r\n\r\n  var data = 'hello I am client';\r\n  var len = Buffer.byteLength(data);\r\n\r\n  //写入2个字节表示本次包长\r\n  var headBuf = new Buffer(2);\r\n  headBuf.writeUInt16BE(len, 0)\r\n  client.write(headBuf);\r\n\r\n  var bodyBuf = new Buffer(len);\r\n  bodyBuf.write(data);\r\n  client.write(bodyBuf);\r\n  \r\n});\r\n\r\nclient.on('data', function(data) {\r\n  exBuffer.put(data);//只要收到数据就往ExBuffer里面put\r\n});\r\n\r\n//当客户端收到完整的数据包时\r\nexBuffer.on('data', function(buffer) {\r\n    console.log('>> client receive data,length:'+buffer.length);\r\n    console.log(buffer.toString());\r\n});\r\n\r\n```\r\n\r\n安装\r\n\r\n```javascript\r\nnpm install ExBuffer\r\n```","tagline":"ExBuffer，NodeJs的TCP中的粘包、分包问题的解决方案！","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}